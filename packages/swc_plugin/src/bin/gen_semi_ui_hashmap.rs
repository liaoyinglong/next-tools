#![feature(absolute_path)]

extern crate s_swc_plugin;

use std::path::{Path, PathBuf};
use std::sync::Arc;

use s_swc_plugin::semi::{SemiImportItem, SemiImportMap};
use swc_core::common::collections::AHashMap;
use swc_core::common::SourceMap;
use swc_core::ecma::ast::ModuleItem;
use swc_core::ecma::parser::{parse_file_as_program, Syntax, TsConfig};
use swc_core::ecma::visit::VisitMut;
use swc_core::ecma::visit::{noop_visit_mut_type, VisitMutWith};

use s_swc_plugin::shared::module_export_name_to_string;

// some-tools/packages/swc_plugin
const WORK_DIR: &str = env!("CARGO_MANIFEST_DIR");

#[derive(Clone, Default)]
struct ConfigItem {
    base: String,
    files: Vec<String>,
    ignore: Vec<String>,
}

impl ConfigItem {
    fn files_to_path_bufs(&self) -> Vec<PathBuf> {
        self.files
            .iter()
            .map(|file| {
                Path::new(WORK_DIR)
                    .join("node_modules")
                    .join(self.base.to_string())
                    .join(file)
            })
            .collect()
    }
}

fn main() {
    let cm = Arc::<SourceMap>::default();
    let mut errors = vec![];
    let mut visitor = CollectImportVisitor::new();
    let mut parse_file_get_map = |config: &ConfigItem, p: &PathBuf| -> Option<()> {
        visitor.set_config(config.clone());
        //#region 收集所有的导出 和 路径
        let fm = cm
            .load_file(&*p)
            .expect(&*format!("failed to load file: {}", p.display()));
        let mut program = parse_file_as_program(
            &*fm,
            Syntax::Typescript(TsConfig {
                tsx: true,
                ..Default::default()
            }),
            Default::default(),
            None,
            &mut errors,
        )
        .ok()?;
        program.visit_mut_with(&mut visitor);
        //#endregion

        None
    };
    let configs = vec![
        ConfigItem {
            base: "@douyinfe/semi-ui/lib/es/".to_string(),
            files: vec!["index.js".to_string()],
            ignore: vec!["Icon".to_string()],
        },
        ConfigItem {
            base: "@douyinfe/semi-icons/lib/es/icons/".to_string(),
            files: vec!["index.js".to_string()],
            ignore: vec![],
        },
    ];
    configs.iter().for_each(|config| {
        config.files_to_path_bufs().iter().for_each(|p| {
            parse_file_get_map(config, p);
        })
    });
    //#region 生成代码
    let code = visitor.imports_to_code();
    let p = Path::new(WORK_DIR).join("src/semi/semi_ui_map.rs");
    std::fs::write(&p, &code).expect(&*format!("failed to write file: {}", p.display()));
    println!("write code to {}", p.display());
    //#endregion
}

/// 收集所有的导出 和 路径
struct CollectImportVisitor {
    // name -> (path, is_named_import)
    pub imports: SemiImportMap,
    config: ConfigItem,
}

impl CollectImportVisitor {
    fn add_to_imports(&mut self, name: String, path: String, is_named_import: bool) {
        if !self.config.ignore.contains(&name) {
            self.imports.insert(
                name,
                SemiImportItem {
                    path,
                    is_named_import,
                },
            );
        }
    }

    fn new() -> Self {
        let mut s = Self {
            imports: AHashMap::default(),
            config: ConfigItem::default(),
        };
        //#region 默认导入
        s.add_to_imports(
            "Icon".to_string(),
            "@douyinfe/semi-icons/lib/es/components/Icon".to_string(),
            false,
        );
        s.add_to_imports(
            "convertIcon".to_string(),
            "@douyinfe/semi-icons/lib/es/components/Icon".to_string(),
            false,
        );
        //#endregion
        s
    }

    fn set_config(&mut self, config: ConfigItem) {
        self.config = config;
    }

    fn imports_to_code(&mut self) -> String {
        let code = r##"
        /// this file is generated by gen_semi_ui_hashmap.rs
        /// do not modify it manually
        use crate::semi::SemiImportMap;
        use once_cell::sync::Lazy;
        pub fn get_semi_ui_map() -> SemiImportMap {
            static SEMI_UI_MAP: Lazy<SemiImportMap> = Lazy::new(|| {
                let json = r#"$JSON$"#;
                serde_json::from_str(json).unwrap()
            });
            SEMI_UI_MAP.clone()
        }
        "##
        .to_string();
        let json = serde_json::to_string_pretty(&self.imports).unwrap();
        let code = code.replace("$JSON$", &json);
        code
    }
}
impl VisitMut for CollectImportVisitor {
    // Implement necessary visit_mut_* methods for actual custom transform.
    // A comprehensive list of possible visitor methods can be found here:
    // https://rustdoc.swc.rs/swc_ecma_visit/trait.VisitMut.html
    noop_visit_mut_type!();
    fn visit_mut_module_items(&mut self, n: &mut Vec<ModuleItem>) {
        n.iter().for_each(|item| {
            let mut work = || -> Option<()> {
                let export = item.as_module_decl()?.as_export_named()?;
                // this get the source of import
                // eg: import { Button } from './button'
                // the source is './button'
                // we should fill absolute path with this source
                // eg: @douyinfe/semi-ui/lib/es/button
                let source = {
                    let temp = export.clone().src?.value.to_string();
                    let mut base = self.config.base.clone();
                    if temp.starts_with("./") {
                        base.push_str(&temp[2..]);
                    } else {
                        base.push_str(&temp);
                    }
                    base
                };

                export.specifiers.iter().for_each(|specifier| {
                    let mut iter_specifiers = || -> Option<()> {
                        let named = specifier.as_named()?;
                        let (name, is_named_import) = match named.clone().exported {
                            // case: export { default as Anchor } from './anchor';
                            Some(exported) => {
                                let name = module_export_name_to_string(exported);
                                (name, false)
                            }
                            // case: export { Anchor } from './anchor';
                            None => {
                                let name = module_export_name_to_string(named.clone().orig);
                                (name, true)
                            }
                        };
                        self.add_to_imports(name, source.clone(), is_named_import);
                        None
                    };
                    iter_specifiers();
                });

                None
            };
            work();
        });

        n.visit_mut_children_with(self);
    }
}
