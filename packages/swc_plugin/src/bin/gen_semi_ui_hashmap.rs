#![feature(absolute_path)]

use std::path::{Path, PathBuf};
use std::sync::Arc;

use swc_core::common::collections::AHashMap;
use swc_core::common::SourceMap;
use swc_core::ecma::ast::ModuleItem;
use swc_core::ecma::parser::{parse_file_as_program, Syntax, TsConfig};
use swc_core::ecma::visit::VisitMut;
use swc_core::ecma::visit::{noop_visit_mut_type, VisitMutWith};
extern crate s_swc_plugin;
use s_swc_plugin::shared::module_export_name_to_string;

// some-tools/packages/swc_plugin
const WORK_DIR: &str = env!("CARGO_MANIFEST_DIR");

struct ConfigItem<'a> {
    base: &'a str,
    files: Vec<&'a str>,
}

impl<'a> ConfigItem<'a> {
    fn files_to_path_bufs(&self) -> Vec<PathBuf> {
        self.files
            .iter()
            .map(|file| {
                Path::new(WORK_DIR)
                    .join("node_modules")
                    .join(self.base)
                    .join(file)
            })
            .collect()
    }
}

fn main() {
    let cm = Arc::<SourceMap>::default();

    let configs = vec![
        ConfigItem {
            base: "@douyinfe/semi-ui/lib/es/",
            files: vec!["index.js"],
        },
        // "@douyinfe/semi-icons/lib/es/index.js",
    ];
    let mut errors = vec![];
    let mut visitor = CollectImportVisitor::new();
    let mut parse_file_get_map = |config: &ConfigItem, p: &PathBuf| -> Option<()> {
        visitor.set_import_base(config.base.to_string());
        //#region 收集所有的导出 和 路径
        let fm = cm
            .load_file(&*p)
            .expect(&*format!("failed to load file: {}", p.display()));
        let mut program = parse_file_as_program(
            &*fm,
            Syntax::Typescript(TsConfig {
                tsx: true,
                ..Default::default()
            }),
            Default::default(),
            None,
            &mut errors,
        )
        .ok()?;
        program.visit_mut_with(&mut visitor);
        //#endregion

        None
    };

    configs.iter().for_each(|config| {
        config.files_to_path_bufs().iter().for_each(|p| {
            parse_file_get_map(config, p);
        })
    });
    //#region 生成代码
    let code = visitor.imports_to_code();
    let p = Path::new(WORK_DIR).join("src/semi/semi_ui_map.rs");
    std::fs::write(&p, &code).expect(&*format!("failed to write file: {}", p.display()));
    println!("write code to {}", p.display());
    //#endregion
}

/// 收集所有的导出 和 路径
struct CollectImportVisitor {
    pub imports: AHashMap<String, String>,
    import_base: String,
}

impl CollectImportVisitor {
    fn new() -> Self {
        Self {
            imports: AHashMap::default(),
            import_base: String::new(),
        }
    }

    fn set_import_base(&mut self, base: String) {
        self.import_base = base;
    }

    fn imports_to_code(&mut self) -> String {
        let mut code = String::new();
        code.push_str(
            r#"
        /// this file is generated by gen_semi_ui_hashmap.rs
        /// do not modify it manually
        use swc_core::common::collections::AHashMap;
        pub fn get_semi_ui_map() -> AHashMap<String, String> {
            let mut map = AHashMap::default();
        "#,
        );
        // 需要排序，否则每次生成的代码都不一样
        let mut vec: Vec<_> = self.imports.iter().collect();
        vec.sort_by_key(|k| k.0);

        vec.iter().for_each(|(k, v)| {
            code.push_str(&*format!(
                "map.insert(\"{}\".to_string(), \"{}\".to_string());",
                k, v
            ));
        });
        code.push_str("map}");
        code
    }
}
impl VisitMut for CollectImportVisitor {
    // Implement necessary visit_mut_* methods for actual custom transform.
    // A comprehensive list of possible visitor methods can be found here:
    // https://rustdoc.swc.rs/swc_ecma_visit/trait.VisitMut.html
    noop_visit_mut_type!();
    fn visit_mut_module_items(&mut self, n: &mut Vec<ModuleItem>) {
        n.iter().for_each(|item| {
            let mut work = || -> Option<()> {
                let export = item.as_module_decl()?.as_export_named()?;
                // this get the source of import
                // eg: import { Button } from './button'
                // the source is './button'
                // we should fill absolute path with this source
                // eg: @douyinfe/semi-ui/lib/es/button
                let source = {
                    let temp = export.clone().src?.value.to_string();
                    let mut base = self.import_base.clone();
                    if temp.starts_with("./") {
                        base.push_str(&temp[2..]);
                    } else {
                        base.push_str(&temp);
                    }
                    base
                };

                export.specifiers.iter().for_each(|specifier| {
                    let mut iter_specifiers = || -> Option<()> {
                        let named = specifier.as_named()?;
                        let name = match named.clone().exported {
                            // case: export { default as Anchor } from './anchor';
                            Some(exported) => module_export_name_to_string(exported),
                            // case: export { Anchor } from './anchor';
                            None => module_export_name_to_string(named.clone().orig),
                        };
                        self.imports.insert(name, source.clone());
                        None
                    };
                    iter_specifiers();
                });

                None
            };
            work();
        });

        n.visit_mut_children_with(self);
    }
}
